/**
 * 冒泡排序
 * 基本思想：使用两层循环，外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾；
 * 优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。第一层循环里设置一个提前退出冒泡循环的标志位，在第二层循环里，当有数据交换时改变它的值，如果经过一次冒泡没有改变过flag的值，则break；
 * 1.空间复杂度：O(1) ，只涉及相邻数据的交换操作，只需要常量级的临时空间，是一个原地排序。

2.稳定性：稳定。当两个相邻的元素大小相等时，不做交换，排序后，其相对位置不变。

3.时间复杂度：

最好情况 ：完全有序，一次冒泡，时间复杂度O(n)

最坏情况：完全逆序，n次冒泡，时间复杂度O(n2)

平均情况：n*(n-1)/4 = O(n2)
 */
var sortArray = function(nums) {
  const len = nums.length;
  // 从后往前遍历
  for(let i=len-1; i>=0; i--){
      let flag = true;
      for(let j=0; j<i; j++){
          if(nums[j]>nums[j+1]){
              const temp = nums[j+1];
              nums[j+1] = nums[j];
              nums[j] = temp;
              flag = false;
          }           
      }
      if(flag) break;
  }
  return nums;
};